#include "pch.h"
#include "PrivacyCore.h"
#include "Processes/ProcessList.h"
#include "Enclaves/EnclaveManager.h"
#include "HashDB/HashDB.h"
#include "Processes/ExecLogEntry.h"
#include "Programs/ProgramManager.h"
#include "Network/NetworkManager.h"
#include "Network/NetLogEntry.h"
#include "Volumes/VolumeManager.h"
#include "Tweaks/TweakManager.h"
#include "../Library/Common/Exception.h"
#include "../Library/Helpers/MiscHelpers.h"
#include "Access/ResLogEntry.h"
#include "Access/AccessManager.h"
#include "../Library/Crypto/HashFunction.h"
#include "Helpers/WinHelper.h"
#include "IssueManager.h"
#include "EventLog.h"
#include "../Library/Helpers/CertUtil.h"
#include "../Library/Helpers/WinUtil.h"
#include "Presets/PresetManager.h"

#include <phnt_windows.h>
#include <phnt.h>

#include "../Library/Helpers/AppUtil.h"
#include "../Library/API/PrivacyAPI.h"
#include "../Library/API/PrivacyAPI.h"
#include "../Library/Helpers/Service.h"
#include "../Library/Helpers/NtPathMgr.h"

#include "../Library/Crypto/Encryption.h"
#include "../Library/Crypto/PrivateKey.h"
#include "../Library/Crypto/PublicKey.h"

CSettings* theConf = NULL;
CPrivacyCore* theCore = NULL;

CPrivacyCore::CPrivacyCore(QObject* parent)
: QThread(parent), m_Driver(CDriverAPI::eDevice)
{
#ifdef _DEBUG
	/*NTSTATUS Status;
	CBuffer Text1((void*)"Hello, World 123Hello, World", 28, true);
	CBuffer Key((void*)"1234567890abcdef", 16, true);
	CBuffer CipherText;
	CBuffer Text2;

	CEncryption Encryption;
	Status = Encryption.SetPassword(CBuffer("1234567890", 10, true));

	Status = Encryption.Encrypt(Text1, CipherText);
	Status = Encryption.Decrypt(CipherText, Text2);

	CPrivateKey PrivateKey;
	CPublicKey PublicKey;
	PrivateKey.MakeKeyPair(PublicKey);

	CBuffer Hash((void*)"Hello, World 123", 16, true);
	CBuffer Signature;
	Status = PrivateKey.Sign(Hash, Signature);
	Status = PublicKey.Verify(Hash, Signature);*/

#endif

	m_pMemPool = FW::MemoryPool::Create();

	m_pSysLog = new CEventLogger(APP_NAME);
	m_pEventLog = new CEventLog(this);
	
	InitHooks();

	m_pSidResolver = new CSidResolver(this);
	m_pSidResolver->Init();

	WCHAR windir[MAX_PATH + 8] = { 0 };
	GetWindowsDirectoryW(windir, MAX_PATH);
	m_WinDir = QString::fromWCharArray(windir);

	this->start();
	m_pWorker = new CPrivacyWorker();
	m_pWorker->moveToThread(this);

	m_pProcessList = new CProcessList(this);
	m_pEnclaveManager = new CEnclaveManager(this);

	m_pHashDB = new CHashDB(this);

	m_pProgramManager = new CProgramManager(this);
	m_pAccessManager = new CAccessManager(this);

	m_pNetworkManager = new CNetworkManager(this);

	m_pVolumeManager = new CVolumeManager(this);

	m_pTweakManager = new CTweakManager(this);

	m_pPresetManager = new CPresetManager(this);

	m_pIssueManager = new CIssueManager(this);


	connect(m_pProgramManager, SIGNAL(ProgramsAdded()), this, SIGNAL(ProgramsAdded()));

	connect(this, SIGNAL(ResRulesChanged()), m_pVolumeManager, SLOT(UpdateProtectedFolders()));

	//
	// Note trace log events always come from the service even though thay are generated by the driver 
	// Rule events are generated by the driver except for firewal
	// 
	// TODO: add own firewall engine to the driver
	//
	//m_Driver.RegisterConfigEventHandler(EConfigGroup::eEnclaves, &CPrivacyCore::OnDrvEvent, this);
	//m_Driver.RegisterConfigEventHandler(EConfigGroup::eHashDB, &CPrivacyCore::OnDrvEvent, this);
	//m_Driver.RegisterConfigEventHandler(EConfigGroup::eAccessRules, &CPrivacyCore::OnDrvEvent, this);
	//m_Driver.RegisterConfigEventHandler(EConfigGroup::eProgramRules, &CPrivacyCore::OnDrvEvent, this);

	//m_Service.RegisterEventHandler(SVC_API_EVENT_PROG_ITEM_CHANGED, &CPrivacyCore::OnProgEvent, this);

	m_Service.RegisterEventHandler(SVC_API_EVENT_LOG_ENTRY, &CPrivacyCore::OnSvcEvent, this);

	m_Service.RegisterEventHandler(SVC_API_EVENT_ENCLAVE_CHANGED, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_HASHDB_CHANGED, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_FW_RULE_CHANGED, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_DNS_RULE_CHANGED, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_EXEC_RULE_CHANGED, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_RES_RULE_CHANGED, &CPrivacyCore::OnSvcEvent, this);

	m_Service.RegisterEventHandler(SVC_API_EVENT_NET_ACTIVITY, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_EXEC_ACTIVITY, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_RES_ACTIVITY, &CPrivacyCore::OnSvcEvent, this);

	m_Service.RegisterEventHandler(SVC_API_EVENT_CLEANUP_PROGRESS, &CPrivacyCore::OnCleanUpDone, this);

	CNtPathMgr::Instance()->RegisterDeviceChangeCallback(DeviceChangedCallback, this);
}

CPrivacyCore::~CPrivacyCore()
{
	m_pWorker->deleteLater();
	this->quit();
	this->wait();

	CNtPathMgr::Instance()->UnRegisterDeviceChangeCallback(DeviceChangedCallback, this);

	// Hack to dispose the memory pool after all child objects are destroyed
	QObject* pDummy = new QObject(this);
	FW::MemoryPool* pMem = m_pMemPool;
	QObject::connect(pDummy, &QObject::destroyed, [pMem](QObject* obj){
		FW::MemoryPool::Destroy(pMem);
	});
}

void CPrivacyCore::DeviceChangedCallback(void* param)
{
	CPrivacyCore* This = (CPrivacyCore*)param;
	emit This->DevicesChanged();
}

STATUS CPrivacyCore__RunAgent(const std::wstring& params, bool bWait = true)
{
	std::wstring Path = GetApplicationDirectory() + L"\\" API_SERVICE_BINARY;

	HANDLE hEngineProcess = RunElevated(Path, params);
	if (!hEngineProcess)
		return ERR(STATUS_UNSUCCESSFUL);

	STATUS Status = OK;
	if (bWait) {
		if (WaitForSingleObject(hEngineProcess, 30 * 1000) == WAIT_OBJECT_0) {
			DWORD exitCode;
			GetExitCodeProcess(hEngineProcess, &exitCode);
			if (exitCode != 0)
				Status = ERR(exitCode);
		}
		else
			Status = ERR(STATUS_TIMEOUT);
	}

	CloseHandle(hEngineProcess);

	return Status;
}

STATUS CPrivacyCore::Start()
{
	SVC_STATE SvcState = GetServiceState(API_SERVICE_NAME);
	if(SvcState & SVC_INSTALLED)
		return CPrivacyCore__RunAgent(L"-startup");
	return CPrivacyCore__RunAgent(L"-engine", false);
}

STATUS CPrivacyCore::Stop()
{
	return CPrivacyCore__RunAgent(L"-unload");
}

STATUS CPrivacyCore::Install()
{
	return CPrivacyCore__RunAgent(L"-install");
}

STATUS CPrivacyCore::Uninstall()
{
	return CPrivacyCore__RunAgent(L"-remove");
}

bool CPrivacyCore::IsSvcInstalled()
{
	SVC_STATE SvcState = GetServiceState(API_SERVICE_NAME);
	return ((SvcState & SVC_INSTALLED) == SVC_INSTALLED);
}

bool CPrivacyCore::IsSvcRunning()
{
	SVC_STATE SvcState = GetServiceState(API_SERVICE_NAME);
	return ((SvcState & SVC_RUNNING) == SVC_RUNNING);
}

bool CPrivacyCore::IsDrvInstalled()
{
	SVC_STATE DrvState = GetServiceState(API_DRIVER_NAME);
	return ((DrvState & SVC_INSTALLED) == SVC_INSTALLED);
}

bool CPrivacyCore::IsDrvRunning()
{
	SVC_STATE DrvState = GetServiceState(API_DRIVER_NAME);
	return ((DrvState & SVC_RUNNING) == SVC_RUNNING);
}

STATUS CPrivacyCore::Connect(bool bCanStart, bool bEngineMode)
{
	m_SvcSecState = 0;

	STATUS Status;
	if (!m_Service.IsConnected())
	{
		if (bCanStart) 
		{
			if (bEngineMode && !IsSvcInstalled())
				Status = m_Service.ConnectEngine(true);
			else
			{
				SVC_STATE SvcState = GetServiceState(API_SERVICE_NAME);
				if ((SvcState & SVC_RUNNING) == 0)
					Status = CPrivacyCore__RunAgent(L"-startup");

				if (Status)
				{
					for (int i = 0; i < 10; i++)
					{
						Status = m_Service.ConnectSvc();
						if (Status)
							break;
						QThread::sleep(1 + i);
					}
				}
			}
		}
		else
			Status = m_Service.ConnectEngine();

		if (Status) {
			uint32 ServiceABI = m_Service.GetABIVersion();
			if(!ServiceABI)
				return ERR(STATUS_PIPE_DISCONNECTED, L"Service NOT Available"); // STATUS_PORT_DISCONNECTED
			if(ServiceABI != MY_ABI_VERSION)
				return ERR(STATUS_REVISION_MISMATCH, L"Service ABI Mismatch");
		} else 
			return Status;
	}

	m_bEngineMode = !IsSvcInstalled();

	if(bEngineMode && !m_bEngineMode)
		theCore->Log()->LogEventLine(EVENTLOG_WARNING_TYPE, 0, SVC_EVENT_SVC_STATUS_MSG, L"Service is installed, engine mod ignored");

	m_ConfigDir = QueryConfigDir();

	if (!m_Driver.IsConnected()) 
	{
		Status = m_Driver.ConnectDrv();

		if (Status) {
			uint32 DriverABI = m_Driver.GetABIVersion();
			if(!DriverABI)
				return ERR(STATUS_DEVICE_NOT_CONNECTED, L"Driver NOT Available");
			if(DriverABI != MY_ABI_VERSION)
				return ERR(STATUS_REVISION_MISMATCH, L"Driver ABI Mismatch");

			// WARNING: this does not work unless we use flt port !!!
			//m_Driver.RegisterForConfigEvents(EConfigGroup::eEnclaves);
			//m_Driver.RegisterForConfigEvents(EConfigGroup::eHashDB);
			//m_Driver.RegisterForConfigEvents(EConfigGroup::eAccessRules);
			//m_Driver.RegisterForConfigEvents(EConfigGroup::eProgramRules);
		}
	}

	auto Result = m_Driver.GetProcessInfo(m_Service.GetProcessId());
	if (!Result.IsError())
	{
		auto Data = Result.GetValue();
		m_SvcSecState = Data->SecState;
	}

	std::wstring BinaryPath = GetServiceBinaryPath(API_DRIVER_NAME);
	BinaryPath = Split2(BinaryPath, L"\\", true).first; // strip file name
	size_t pos = BinaryPath.find_last_of(L'\\');
	if (pos != std::wstring::npos) { // strip sub folder name
		if (BinaryPath.compare(pos, 4, L"\\x64") == 0 || BinaryPath.compare(pos, 6, L"\\AMD64") == 0
		 || BinaryPath.compare(pos, 4, L"\\A64") == 0 || BinaryPath.compare(pos, 6, L"\\ARM64") == 0)
			BinaryPath.resize(pos);
	}
	m_AppDir = NormalizePath(QString::fromStdWString(BinaryPath));

	QtVariant Request(m_pMemPool);
	auto ret = m_Service.Call(SVC_API_GET_EVENT_LOG, Request);
	if (!ret.IsError())
		m_pEventLog->LoadEntries(ret.GetValue().Get(API_V_EVENT_LOG));

	return Status;
}

void CPrivacyCore::Disconnect(bool bKeepEngine)
{
	m_Driver.Disconnect();

	if (m_bEngineMode && !bKeepEngine)
		m_Service.Call(SVC_API_SHUTDOWN, QtVariant(m_pMemPool));
	m_Service.Disconnect();

	m_EnclavesUpToDate = false;
	m_HashDBUpToDate = false;
	m_ProgramRulesUpToDate = false;
	m_AccessRulesUpToDate = false;
	m_FwRulesUpToDate = false;
	m_DnsRulesUpToDate = false;
}

uint32 CPrivacyCore::GetServicePID() const
{
	return m_Service.GetProcessId();
}

bool CPrivacyCore::IsSvcHighSecurity() const
{
	return ((m_SvcSecState & KPH_PROCESS_STATE_HIGH) == KPH_PROCESS_STATE_HIGH);
}

bool CPrivacyCore::IsSvcMaxSecurity() const
{
	return ((m_SvcSecState & KPH_PROCESS_STATE_MAXIMUM) == KPH_PROCESS_STATE_MAXIMUM);
}

STATUS CPrivacyCore::Update()
{
	auto Ret = GetServiceStats();
	if (Ret.IsError())
		return Ret.GetStatus();
	QtVariant Stats = Ret.GetValue();

	m_TotalMemoryUsed = Stats[API_V_SVC_MEM_PB].To<uint64>();
	m_LogMemoryUsed = Stats[API_V_LOG_MEM_USAGE].To<uint64>();

	QMetaObject::invokeMethod(m_pWorker, "DoUpdate", Qt::QueuedConnection);

	return OK;
}

void CPrivacyCore::ProcessEvents()
{
	QMutexLocker Lock(&m_EventQueueMutex);
	//auto ProcRuleEvents = m_DrvEventQueue.take(EItemType::eExecRule);
	//auto ResRuleEvents = m_DrvEventQueue.take(EItemType::eResRule);
	
	auto LogEvents = m_SvcEventQueue.take(SVC_API_EVENT_LOG_ENTRY);

	auto EnclaveEvents = m_SvcEventQueue.take(SVC_API_EVENT_ENCLAVE_CHANGED);
	auto HashDBEvents = m_SvcEventQueue.take(SVC_API_EVENT_HASHDB_CHANGED);
	auto FwRuleEvents = m_SvcEventQueue.take(SVC_API_EVENT_FW_RULE_CHANGED);
	auto DnsRuleEvents = m_SvcEventQueue.take(SVC_API_EVENT_DNS_RULE_CHANGED);
	auto ExecRuleEvents = m_SvcEventQueue.take(SVC_API_EVENT_EXEC_RULE_CHANGED);
	auto ResRuleEvents = m_SvcEventQueue.take(SVC_API_EVENT_RES_RULE_CHANGED);

	auto NetEvents = m_SvcEventQueue.take(SVC_API_EVENT_NET_ACTIVITY);
	auto ExecEvents = m_SvcEventQueue.take(SVC_API_EVENT_EXEC_ACTIVITY);
	auto ResEvents = m_SvcEventQueue.take(SVC_API_EVENT_RES_ACTIVITY);
	Lock.unlock();


	if (!LogEvents.isEmpty()) {
		foreach(const QtVariant & vEvent, LogEvents)
			m_pEventLog->AddEntry(vEvent, true);
	}


	//////////////////
	// Enclaves

	if (!m_EnclavesUpToDate) {
		if (m_pEnclaveManager->UpdateAllEnclaves()) {
			m_EnclavesUpToDate = true;
			emit EnclavesChanged();
		}
	}
	else if(!EnclaveEvents.isEmpty()) {
		foreach(const QtVariant& vEvent, EnclaveEvents) {
			QFlexGuid Guid;
			Guid.FromVariant(vEvent[API_V_GUID]);
			if (vEvent[API_V_EVENT_TYPE].To<uint32>() == (uint32)EConfigEvent::eRemoved)
				m_pEnclaveManager->RemoveEnclave(Guid);
			else
				m_pEnclaveManager->UpdateEnclave(Guid);
		}
		emit EnclavesChanged();
	}

	//////////////////
	// HashDB

	if (!m_HashDBUpToDate) {
		if (m_pHashDB->UpdateAllHashes()) {
			m_HashDBUpToDate = true;
			emit HashDBChanged();
		}
	}
	else if(!HashDBEvents.isEmpty()) {
		foreach(const QtVariant& vEvent, HashDBEvents) {
			QByteArray HashValue = QByteArray::fromHex(vEvent[API_V_GUID].AsQStr().toLatin1());
			if (vEvent[API_V_EVENT_TYPE].To<uint32>() == (uint32)EConfigEvent::eRemoved)
				m_pHashDB->RemoveHash(HashValue);
			else
				m_pHashDB->UpdateHash(HashValue);
		}
		emit HashDBChanged();
	}

	//////////////////
	// Rules

	if (!m_ProgramRulesUpToDate) {
		if (m_pProgramManager->UpdateAllProgramRules()) {
			m_ProgramRulesUpToDate = true;
			emit ExecRulesChanged();
		}
	}
	else if(!ExecRuleEvents.isEmpty()) {
		foreach(const QtVariant& vEvent, ExecRuleEvents) {
			QFlexGuid Guid;
			Guid.FromVariant(vEvent[API_V_GUID]);
			if (vEvent[API_V_EVENT_TYPE].To<uint32>() == (uint32)EConfigEvent::eRemoved)
				m_pProgramManager->RemoveProgramRule(Guid);
			else
				m_pProgramManager->UpdateProgramRule(Guid);
		}
		emit ExecRulesChanged();
	}

	if (!m_AccessRulesUpToDate) {
		if (m_pAccessManager->UpdateAllAccessRules()) {
			m_AccessRulesUpToDate = true;
			emit ResRulesChanged();
		}
	}
	else if(!ResRuleEvents.isEmpty()){
		foreach(const QtVariant& vEvent, ResRuleEvents) {
			QFlexGuid Guid;
			Guid.FromVariant(vEvent[API_V_GUID]);
			if (vEvent[API_V_EVENT_TYPE].To<uint32>() == (uint32)EConfigEvent::eRemoved)
				m_pAccessManager->RemoveAccessRule(Guid);
			else
				m_pAccessManager->UpdateAccessRule(Guid);
		}
		emit ResRulesChanged();
	}

	if (!m_FwRulesUpToDate) {
		if (m_pNetworkManager->UpdateAllFwRules()) {
			m_FwRulesUpToDate = true;
			emit FwRulesChanged();
		}
	}
	else if(!FwRuleEvents.isEmpty()){
		foreach(const QtVariant& vEvent, FwRuleEvents) {
			QFlexGuid Guid;
			Guid.FromVariant(vEvent[API_V_GUID]);
			qint32 iEventType = vEvent[API_V_EVENT_TYPE].To<uint32>();
			if (iEventType == (qint32)EConfigEvent::eRemoved)
				m_pNetworkManager->RemoveFwRule(Guid);
			else
				m_pNetworkManager->UpdateFwRule(Guid);

			if (!vEvent[API_V_EVENT_EXPECTED].To<bool>())
				emit FwChangeEvent(Guid.ToQS(), iEventType);
		}
		emit FwRulesChanged();
	}

	if (!m_DnsRulesUpToDate) {
		if (m_pNetworkManager->UpdateAllDnsRules()) {
			m_DnsRulesUpToDate = true;
			emit DnsRulesChanged();
		}
	}
	else if(!DnsRuleEvents.isEmpty()){
		foreach(const QtVariant& vEvent, DnsRuleEvents) {
			QFlexGuid Guid;
			Guid.FromVariant(vEvent[API_V_GUID]);
			if (vEvent[API_V_EVENT_TYPE].To<uint32>() == (uint32)EConfigEvent::eRemoved)
				m_pNetworkManager->RemoveDnsRule(Guid);
			else
				m_pNetworkManager->UpdateDnsRule(Guid);
		}
		emit DnsRulesChanged();
	}

	//////////////////
	// Events

	foreach(const QtVariant& Event, NetEvents)
	{
		//QJsonDocument doc(QJsonValue::fromVariant(Event.ToQVariant()).toObject());			
		//QByteArray data = doc.toJson();

		CProgramID ID;
		ID.FromVariant(Event[API_V_ID]);
		CProgramFilePtr pProgram = m_pProgramManager->GetProgramFile(ID.GetFilePath());
		if (!pProgram) continue;

		CNetLogEntry* pNetEnrty = new CNetLogEntry();
		CLogEntryPtr pEntry = CLogEntryPtr(pNetEnrty);
		pEntry->FromVariant(Event[API_V_EVENT_DATA]);
		pProgram->TraceLogAdd(ETraceLogs::eNetLog, pEntry, Event[API_V_EVENT_INDEX]);

		if (pNetEnrty->GetState() == EFwEventStates::UnRuled)
			emit UnruledFwEvent(pProgram, pEntry);

		foreach(const CFwRulePtr& pRule, m_pNetworkManager->GetFwRules(pNetEnrty->GetAllowRules() | pNetEnrty->GetBlockRules()))
			pRule->IncrHitCount();
	}

	foreach(const QtVariant& Event, ExecEvents)
	{
		CProgramID ID;
		ID.FromVariant(Event[API_V_ID]);
		CProgramFilePtr pProgram = m_pProgramManager->GetProgramFile(ID.GetFilePath());
		if (!pProgram) continue;

		CExecLogEntry* pExecEnrty = new CExecLogEntry();
		CLogEntryPtr pEntry = CLogEntryPtr(pExecEnrty);
		pEntry->FromVariant(Event[API_V_EVENT_DATA]);
		quint64 LogIndex = Event[API_V_EVENT_INDEX];
		if(LogIndex != -1)
			pProgram->TraceLogAdd(ETraceLogs::eExecLog, pEntry, LogIndex);

		switch (pExecEnrty->GetType())
		{
		case EExecLogType::eImageLoad:
			if (pExecEnrty->GetStatus() == EEventStatus::eBlocked)
				emit ExecutionEvent(pProgram, pEntry);
			break;
		case EExecLogType::eProcessStarted:
			//if (pExecEnrty->GetRole() == EExecLogRole::eActor && pExecEnrty->GetStatus() == EEventStatus::eProtected)
			if (pExecEnrty->GetRole() == EExecLogRole::eTarget && pExecEnrty->GetStatus() == EEventStatus::eProtected)
				emit ExecutionEvent(pProgram, pEntry);
			break;
		}
	}

	foreach(const QtVariant& Event, ResEvents)
	{
		CProgramID ID;
		ID.FromVariant(Event[API_V_ID]);
		CProgramFilePtr pProgram = m_pProgramManager->GetProgramFile(ID.GetFilePath());
		if (!pProgram) continue;

		CResLogEntry* pResEnrty = new CResLogEntry();
		CLogEntryPtr pEntry = CLogEntryPtr(pResEnrty);
		pEntry->FromVariant(Event[API_V_EVENT_DATA]);
		pProgram->TraceLogAdd(ETraceLogs::eResLog, pEntry, Event[API_V_EVENT_INDEX]);

		if (pResEnrty->GetStatus() == EEventStatus::eProtected) {
			uint32 TimeOut = Event[API_V_EVENT_TIMEOUT].To<uint32>(0);
			emit AccessEvent(pProgram, pEntry, TimeOut);
		}
	}
}

//void CPrivacyCore::OnProgEvent(uint32 MessageId, const CBuffer* pEvent)
//{
//	// WARNING: this function is invoked from a worker thread !!!
//
//}

void CPrivacyCore::OnSvcEvent(uint32 MessageId, const CBuffer* pEvent)
{
	// WARNING: this function is invoked from a worker thread !!!

	QtVariant vEvent;
	try {
		vEvent.FromPacket(pEvent);
	}
	catch (const CException&)
	{
		ASSERT(0);
		return;
	}

	switch(MessageId)
	{
	case SVC_API_EVENT_ENCLAVE_CHANGED:
		if (vEvent[API_V_EVENT_TYPE].To<uint32>() == (uint32)EConfigEvent::eAllChanged)
			m_EnclavesUpToDate = false;
		break;
	case SVC_API_EVENT_HASHDB_CHANGED:
		if (vEvent[API_V_EVENT_TYPE].To<uint32>() == (uint32)EConfigEvent::eAllChanged)
			m_HashDBUpToDate = false;
		break;
	case SVC_API_EVENT_RES_RULE_CHANGED:
		if (vEvent[API_V_EVENT_TYPE].To<uint32>() == (uint32)EConfigEvent::eAllChanged)
			m_ProgramRulesUpToDate = false;
		break;
	case SVC_API_EVENT_EXEC_RULE_CHANGED:
		if (vEvent[API_V_EVENT_TYPE].To<uint32>() == (uint32)EConfigEvent::eAllChanged)
			m_AccessRulesUpToDate = false;
		break;
	}

	QMutexLocker Lock(&m_EventQueueMutex);
	QQueue<QtVariant>& Queue = m_SvcEventQueue[MessageId];
	/*if (Queue.size() > 10000) {
		ASSERT(0);
		return;
	}*/
	Queue.enqueue(vEvent);
}

void CPrivacyCore::OnCleanUpDone(uint32 MessageId, const CBuffer* pEvent)
{
	// WARNING: this function is invoked from a worker thread !!!

	QtVariant vEvent;
	try {
		vEvent.FromPacket(pEvent);
	}
	catch (const CException&)
	{
		ASSERT(0);
		return;
	}

	if (vEvent[API_V_PROGRESS_FINISHED].To<bool>())
		emit CleanUpDone();
	else
		emit CleanUpProgress(vEvent[API_V_PROGRESS_DONE].To<quint64>(), vEvent[API_V_PROGRESS_TOTAL].To<quint64>());
}

void CPrivacyCore::Clear()
{
	m_pProgramManager->Clear();
}

void CPrivacyCore::OnClearTraceLog(const CProgramItemPtr& pItem, ETraceLogs Log)
{
	if (auto pProgram = pItem.objectCast<CProgramFile>())
		pProgram->ClearTraceLog(Log);
}

void CPrivacyCore::OnClearRecords(const CProgramItemPtr& pItem, ETraceLogs Log)
{
	if (auto pProgram = pItem.objectCast<CProgramFile>())
	{
		if(Log == ETraceLogs::eLogMax || Log == ETraceLogs::eResLog)
			pProgram->ClearAccessLog();
		if(Log == ETraceLogs::eLogMax || Log == ETraceLogs::eExecLog)
			pProgram->ClearProcessLogs();
		if(Log == ETraceLogs::eLogMax || Log == ETraceLogs::eNetLog)
			pProgram->ClearTrafficLog();
	}
	if (auto pService = pItem.objectCast<CWindowsService>())
	{
		if(Log == ETraceLogs::eLogMax || Log == ETraceLogs::eResLog)
			pService->ClearAccessLog();
		if(Log == ETraceLogs::eLogMax || Log == ETraceLogs::eExecLog)
			pService->ClearProcessLogs();
		if(Log == ETraceLogs::eLogMax || Log == ETraceLogs::eNetLog)
			pService->ClearTrafficLog();

	}
}

/*void CPrivacyCore::OnDrvEvent(const std::wstring& Guid, enum class EConfigEvent Event, enum class EConfigGroup Type, uint64 PID)
{
	// WARNING: this function is invoked from a worker thread !!!

	QMutexLocker Lock(&m_EventQueueMutex);
	//m_DrvEventQueue[Type].enqueue(SDrvRuleEvent { QString::fromStdWString(Guid), Event });
}*/

QString CPrivacyCore::NormalizePath(QString sPath, bool bForID)
{
	if(sPath.isEmpty() || sPath[0] == '*')
		return sPath;

	std::wstring Path = sPath.toStdWString();

	if (Path.length() >= 7 && Path.compare(0, 4, L"\\??\\") == 0 && Path.compare(5, 2, L":\\") == 0) // \??\X:\...
		Path.erase(0, 4);
	else if (Path.length() >= 7 && Path.compare(0, 4, L"\\\\?\\") == 0 && Path.compare(5, 2, L":\\") == 0) // \\?\X:\...
		Path.erase(0, 4);

	if (Path.find(L'%') != std::wstring::npos)
		Path = ExpandEnvironmentVariablesInPath(Path);

	if (MatchPathPrefix(Path, L"\\SystemRoot")) {
		Path = theCore->m_WinDir.toStdWString() + Path.substr(11);
	}

	if (!bForID && _wcsnicmp(Path.c_str(), L"\\device\\mup\\", 12) == 0)
		Path = L"\\\\" + Path.substr(12);
	else

	if (!CNtPathMgr::IsDosPath(Path) && _wcsnicmp(Path.c_str(), L"\\REGISTRY\\", 10) != 0)
	{
		if (_wcsnicmp(Path.c_str(), L"\\Device\\", 8) == 0)
			Path = L"\\\\.\\" + Path.substr(8);
		
		if (Path.length() >= 4 && Path.compare(0, 4, L"\\\\.\\") == 0) 
		{
			std::wstring DevicePath = L"\\Device\\" + Path.substr(4);
			std::wstring DosPath = CNtPathMgr::Instance()->TranslateNtToDosPath(DevicePath);
			if (!DosPath.empty())
				Path = DosPath;
			else if (bForID) 
				Path = DevicePath;
		}
	}

	sPath = QString::fromStdWString(Path);
	return bForID ? sPath.toLower() : sPath;
}

STATUS CPrivacyCore::HashFile(const QString& Path, CBuffer& Hash)
{
	QFile File(Path);
	if (!File.open(QIODevice::ReadOnly))
		return ERR(STATUS_NOT_FOUND);

	CHashFunction HashFunction;
	STATUS Status = HashFunction.InitHash();
	if (Status.IsError()) return Status;

	CBuffer Buffer(0x1000);
	for (;;) {
		int Read = File.read((char*)Buffer.GetBuffer(), Buffer.GetCapacity());
		if (Read <= 0) break;
		Buffer.SetSize(Read);
		Status = HashFunction.UpdateHash(Buffer);
		if (Status.IsError()) return Status;
	}

	Status = HashFunction.FinalizeHash(Hash);
	if (Status.IsError()) return Status;

	return OK;
}

/*QByteArray CPrivacyCore__MakeFileSig(const CBuffer& Signature, const QString& Path)
{
	QtVariant SigData;
	// Note: the driver supportrs also teh V version
	SigData[API_S_VERSION] = DEF_MP_SIG_VERSION;
	SigData[API_S_SIGNATURE] = Signature;
	SigData[API_S_TYPE] = "File";
	SigData[API_S_FILE_PATH] = Path;

	CBuffer SigBuffer;
	SigData.ToPacket(&SigBuffer);
	return QByteArray((char*)SigBuffer.GetBuffer(), SigBuffer.GetSize());
}

QByteArray CPrivacyCore__MakeCertSig(const CBuffer& Signature, const QString& Subject)
{
	QtVariant SigData;
	// Note: the driver supportrs also teh V version
	SigData[API_S_VERSION] = DEF_MP_SIG_VERSION;
	SigData[API_S_SIGNATURE] = Signature;
	SigData[API_S_TYPE] = "Certificate";
	SigData[API_S_NAME] = Subject;

	CBuffer SigBuffer;
	SigData.ToPacket(&SigBuffer);
	return QByteArray((char*)SigBuffer.GetBuffer(), SigBuffer.GetSize());
}

STATUS CPrivacyCore::SignFiles(const QStringList& Paths, const CPrivateKey* pPrivateKey)
{
	STATUS Status;
	foreach(QString Path, Paths)
	{
		Path.replace("/", "\\");

		CBuffer Hash;
		Status = HashFile(Path, Hash);

		CBuffer Signature;
		Status = pPrivateKey->Sign(Hash, Signature);
		if (Status.IsError()) continue;

		QString Name = Split2(Path, "\\", true).second;
		QString SignaturePath = "\\sig_db\\" + Name;
		SignaturePath += "\\" + QByteArray((char*)Hash.GetBuffer(), Hash.GetSize()).toHex().toUpper() + ".mpsig";

		Status = WriteConfigFile(SignaturePath, CPrivacyCore__MakeFileSig(Signature, Path));
		if(!Status.IsError())
			m_SigFileCache[Path] = 1;
	}
	return Status;
}

QString CPrivacyCore::GetSignatureFilePath(const QString& Path, QByteArray Hash)
{
	QString Name = Split2(Path, "\\", true).second;
	QString SignaturePath = Name + ".mpsig";
	if (QFile::exists(SignaturePath))
		return SignaturePath;
	
	SignaturePath = "\\sig_db\\" + Name;
	if (!CheckConfigFile(SignaturePath)) return "";
		
	if (Hash.isEmpty())
	{
		CBuffer HashBuff;
		STATUS Status = HashFile(Path, HashBuff);
		if (Status.IsError()) 
			return "";
		Hash = QByteArray((char*)HashBuff.GetBuffer(), HashBuff.GetSize());
	}
	
	SignaturePath += "\\" + Hash.toHex().toUpper() + ".mpsig";
	return SignaturePath;
}

bool CPrivacyCore::HasFileSignature(const QString& Path, const QByteArray& Hash)
{
	int State = m_SigFileCache.value(Path, -1);
	if(State != -1)
		return State == 1;
	State = 0;

	QString SignaturePath = GetSignatureFilePath(Path, Hash);
	if (!SignaturePath.isEmpty()) {
		if (SignaturePath.at(0) == '\\' ? CheckConfigFile(SignaturePath) : QFile::exists(SignaturePath))
			State = 1;
	}

	m_SigFileCache.insert(Path, State);
	return State == 1;
}

STATUS CPrivacyCore::RemoveFileSignature(const QStringList& Paths)
{
	STATUS Status;
	foreach(const QString& Path, Paths)
	{
		QString SignaturePath = GetSignatureFilePath(Path);
		if (!SignaturePath.isEmpty()) {
			if (SignaturePath.at(0) == '\\')
				Status = RemoveConfigFile(SignaturePath);
			else
				Status = QFile::remove(SignaturePath) ? OK : ERR(STATUS_UNSUCCESSFUL);
		}
		if(!Status.IsError())
			m_SigFileCache[Path] = 0;
	}
	return Status;
}

STATUS CPrivacyCore::SignCerts(const QMap<QByteArray, QString>& Certs, const class CPrivateKey* pPrivateKey)
{
	STATUS Status;
	for(auto I = Certs.begin(); I != Certs.end(); ++I)
	{
		QByteArray SignerHash = I.key();
		QString Subject = I.value();
		
		CBuffer Signature;
		Status = pPrivateKey->Sign(CBuffer((void*)SignerHash.data(), SignerHash.size(), true), Signature);
		if (Status.IsError()) continue;

		QString SignaturePath = "\\sig_db\\" + Subject;
		QDir().mkpath(SignaturePath);
		SignaturePath += "\\" + SignerHash.toHex().toUpper() + ".mpsig";
		
		Status = WriteConfigFile(SignaturePath, CPrivacyCore__MakeCertSig(Signature, Subject));
		if(!Status.IsError())
			m_SigFileCache[Subject + "/" + SignerHash] = 1;
	}
	return Status;
}

bool CPrivacyCore::HasCertSignature(const QString& Subject, const QByteArray& SignerHash)
{
	if(SignerHash.isEmpty())
		return false;

	int State = m_SigFileCache.value(Subject + "/" + SignerHash, -1);
	if(State != -1)
		return State == 1;
	State = 0;

	QString SignaturePath = "\\sig_db\\" + Subject;
	SignaturePath += "\\" + SignerHash.toHex().toUpper() + ".mpsig";

	if (CheckConfigFile(SignaturePath))
		State = 1;

	m_SigFileCache.insert(Subject + "/" + SignerHash, State);
	return State == 1;
}

STATUS CPrivacyCore::RemoveCertSignature(const QMap<QByteArray, QString>& Certs)
{
	STATUS Status;
	for(auto I = Certs.begin(); I != Certs.end(); ++I)
	{
		QByteArray SignerHash = I.key();
		QString Subject = I.value();

		QString SignaturePath = "\\sig_db\\" + Subject;
		SignaturePath += "\\" + SignerHash.toHex().toUpper() + ".mpsig";

		Status = RemoveConfigFile(SignaturePath);
		if(!Status.IsError())
			m_SigFileCache[Subject + "/" + SignerHash] = 0;
	}
	return Status;
}*/

std::shared_ptr<struct SEmbeddedCIInfo> CPrivacyCore::GetEmbeddedCIInfo(const std::wstring& filePath)
{
	auto F = m_EmbeddedSigCache.find(filePath);
	if (F != m_EmbeddedSigCache.end())
	{
		return F->second.Info;
	}
	std::shared_ptr<struct SEmbeddedCIInfo> pInfo = ::GetEmbeddedCIInfo(filePath);
	if(pInfo)
		m_EmbeddedSigCache[filePath].Info = pInfo;
	return pInfo;
}

std::shared_ptr<struct SCatalogCIInfo> CPrivacyCore::GetCatalogCIInfo(const std::wstring& filePath)
{
	auto F = m_CatalogSigCache.find(filePath);
	if (F != m_CatalogSigCache.end())
	{
		return F->second.Info;
	}
	std::shared_ptr<struct SCatalogCIInfo> pInfo = ::GetCatalogCIInfo(filePath);
	if(pInfo)
		m_CatalogSigCache[filePath].Info = pInfo;
	return pInfo;
}

void CPrivacyCore::ClearCIInfoCache()
{
	m_EmbeddedSigCache.clear();
	m_CatalogSigCache.clear();
}

QtVariant CPrivacyCore::MakeIDs(const QList<const class CProgramItem*>& Nodes)
{
	SVarWriteOpt Opts;

	QtVariant IDs;
	foreach(auto Item, Nodes) 
	{
		IDs.Append(Item->GetID().ToVariant(Opts));
	}
	return IDs;
}

#define RET_AS_XVARIANT(r) \
auto Ret = r; \
if (Ret.IsError()) \
return ERR(Ret.GetStatus()); \
RETURN((QtVariant&)Ret.GetValue());

#define RET_GET_XVARIANT(r, n) \
auto Ret = r; \
if (Ret.IsError()) \
return ERR(Ret.GetStatus()); \
const QtVariant& Res = (const FW::CVariant&)Ret.GetValue(); \
RETURN((QtVariant&)Res.Get(n));

QString CPrivacyCore::QueryConfigDir()
{
	QtVariant Request(m_pMemPool);
	auto Ret = m_Service.Call(SVC_API_GET_CONFIG_DIR, Request);
	if (Ret.IsError())
		return "";
	QtVariant& Response = (QtVariant&)Ret.GetValue();
	return Response[API_V_VALUE].AsQStr();
}

bool CPrivacyCore::CheckConfigFile(const QString& Name)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_FILE_PATH] = Name;
	auto Ret = m_Service.Call(SVC_API_CHECK_CONFIG_FILE, Request);
	if (Ret.IsError())
		return false;
	QtVariant& Response = (QtVariant&)Ret.GetValue();
	return Response.To<bool>();
}

RESULT(QByteArray) CPrivacyCore::ReadConfigFile(const QString& Name)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_FILE_PATH] = Name;
	auto Ret = m_Service.Call(SVC_API_GET_CONFIG_FILE, Request);
	if (Ret.IsError())
		return Ret.GetStatus();
	QtVariant& Response = (QtVariant&)Ret.GetValue();
	return Response[API_V_DATA].AsQBytes();
}

STATUS CPrivacyCore::WriteConfigFile(const QString& Name, const QByteArray& Data)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_FILE_PATH] = Name;
	Request[API_V_DATA] = QtVariant(Data);
	return m_Service.Call(SVC_API_SET_CONFIG_FILE, Request);
}

STATUS CPrivacyCore::RemoveConfigFile(const QString& Name)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_FILE_PATH] = Name;
	return m_Service.Call(SVC_API_DEL_CONFIG_FILE, Request);
}

RESULT(QStringList) CPrivacyCore::ListConfigFiles(const QString& Name)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_FILE_PATH] = Name;
	auto Ret = m_Service.Call(SVC_API_LIST_CONFIG_FILES, Request);
	if (Ret.IsError())
		return Ret.GetStatus();
	//
	// Note: the returned names are sufixed with L'\\' if they represent a directory
	//
	QtVariant& Response = (QtVariant&)Ret.GetValue();
	return Response[API_V_FILES].AsQList();
}

RESULT(QtVariant) CPrivacyCore::GetConfig(const QString& Name) 
{
	QtVariant Request(m_pMemPool);
	Request[API_V_KEY] = Name;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_CONFIG, Request), API_V_VALUE);
}

STATUS CPrivacyCore::SetConfig(const QString& Name, const QtVariant& Value)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_KEY] = Name;
	Request[API_V_VALUE] = Value;
	return m_Service.Call(SVC_API_SET_CONFIG, Request);
}

RESULT(QtVariant) CPrivacyCore::GetSvcConfig()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_CONFIG, Request), API_V_DATA);
}

STATUS CPrivacyCore::SetSvcConfig(const QtVariant& Data)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_DATA] = Data;
	return m_Service.Call(SVC_API_SET_CONFIG, Request);
}

//RESULT(QtVariant) CPrivacyCore::GetDrvConfig(const QString& Name)
//{
//	QtVariant Request(m_pMemPool);
//	Request[API_V_KEY] = Name;
//	RET_AS_XVARIANT(m_Driver.Call(API_GET_CONFIG_VALUE, Request), API_V_VALUE);
//}
//
//STATUS CPrivacyCore::SetDrvConfig(const QString& Name, const QtVariant& Value)
//{
//	QtVariant Request(m_pMemPool);
//	Request[API_V_KEY] = Name;
//	Request[API_V_VALUE] = Value;
//	return m_Driver.Call(API_SET_CONFIG_VALUE, Request);
//}

RESULT(QtVariant) CPrivacyCore::GetDrvConfig()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Driver.Call(API_GET_CONFIG_VALUE, Request), API_V_DATA);
}

STATUS CPrivacyCore::SetDrvConfig(const QtVariant& Data)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_DATA] = Data;
	return m_Driver.Call(API_SET_CONFIG_VALUE, Request);
}

// Process Manager
RESULT(QtVariant) CPrivacyCore::GetProcesses()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_PROCESSES, Request), API_V_PROCESSES);
}

RESULT(QtVariant) CPrivacyCore::GetProcess(uint64 Pid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_PID] = Pid;
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_PROCESS, Request))
}

STATUS CPrivacyCore::StartProcessBySvc(const QString& Command)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_CMD_LINE] = Command;
	return m_Service.Call(SVC_API_START_SECURE, Request);
}

STATUS CPrivacyCore::TerminateProcess(uint64 Pid)
{
	//QtVariant Request(m_pMemPool);
	//Request[API_V_PID] = Pid;
	//return m_Service.Call(SVC_API_TERMINATE_PROCESS, Request);

	NTSTATUS status;

	OBJECT_ATTRIBUTES objectAttributes;
	InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);

	CLIENT_ID clientId;
	clientId.UniqueProcess = (HANDLE)Pid;
	clientId.UniqueThread = NULL;
	
	CScopedHandle hProcess((HANDLE)NULL, CloseHandle);
	status = NtOpenProcess(&hProcess, PROCESS_TERMINATE, &objectAttributes, &clientId);
	if (NT_SUCCESS(status))
		status = NtTerminateProcess(hProcess, STATUS_SUCCESS);
	if(!NT_SUCCESS(status))
		return ERR(status);
	return OK;
}

RESULT(int) CPrivacyCore::RunUpdateUtility(const QStringList& Params, quint32 Elevate, bool Wait)
{
	QString Command;
	foreach(const QString & Param, Params) {
		if (!Command.isEmpty()) Command += " ";
		Command += "\"" + Param + "\"";
	}

	QtVariant Request(m_pMemPool);
	Request[API_V_CMD_LINE] = Command;
	Request[API_V_ELEVATE] = Elevate;
	Request[API_V_WAIT] = Wait;
	auto Ret = m_Service.Call(SVC_API_RUN_UPDATER, Request);
	if (Ret.IsError())
		return Ret;

	auto Reply = Ret.GetValue();

	HANDLE hProcess = (HANDLE)Reply[API_V_HANDLE].To<uint64>();
	
	DWORD ExitCode = 0;
	if (Wait) {
		WaitForSingleObject(hProcess, INFINITE);
		GetExitCodeProcess(hProcess, &ExitCode);
	}

	CloseHandle(hProcess);

	return CResult<int>(0, ExitCode);
}

// Secure Enclaves
STATUS CPrivacyCore::SetAllEnclaves(const QtVariant& Enclaves)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ENCLAVES] = Enclaves;
	return m_Driver.Call(API_SET_ENCLAVES, Request);
}

RESULT(QtVariant) CPrivacyCore::GetAllEnclaves()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Driver.Call(API_GET_ENCLAVES, Request), API_V_ENCLAVES);
}

RESULT(QFlexGuid) CPrivacyCore::SetEnclave(const QtVariant& Enclave)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ENCLAVE] = Enclave;
	auto Ret = m_Driver.Call(API_SET_ENCLAVE, Request);
	if (Ret.IsError())
		return Ret;
	return QFlexGuid(Ret.GetValue());
}

RESULT(QtVariant) CPrivacyCore::GetEnclave(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	RET_GET_XVARIANT(m_Driver.Call(API_GET_ENCLAVE, Request), API_V_ENCLAVE);
}

STATUS CPrivacyCore::DelEnclave(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	return m_Driver.Call(API_DEL_ENCLAVE, Request);
}

STATUS CPrivacyCore::StartProcessInEnclave(const QString& Command, const QFlexGuid& Guid)
{
	STATUS Status = m_Driver.PrepareEnclave(Guid);
	if (Status.IsError())
		return Status;

	STARTUPINFOW si = { 0 };
	si.cb = sizeof(si);
	PROCESS_INFORMATION pi = { 0 };
	if (CreateProcessW(NULL, (wchar_t*)Command.utf16(), NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
	{
		CProcessPtr pProcess = theCore->ProcessList()->GetProcess(pi.dwProcessId, true);
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);

		if(!pProcess)
			return ERR(STATUS_UNSUCCESSFUL);

		KPH_PROCESS_SFLAGS SecFlags;
		SecFlags.SecFlags = pProcess->GetSecFlags();
		if (SecFlags.EjectFromEnclave)
			return ERR(STATUS_ERR_PROC_EJECTED);
	} 
	else
		return ERR(STATUS_UNSUCCESSFUL); // todo make a better error code
	return OK;
}

// HashDB
STATUS CPrivacyCore::SetAllHashes(const QtVariant& Entries)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ENTRIES] = Entries;
	return m_Driver.Call(API_SET_HASHES, Request);
}

RESULT(QtVariant) CPrivacyCore::GetAllHashes()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Driver.Call(API_GET_HASHES, Request), API_V_ENTRIES);
}

STATUS CPrivacyCore::SetHashEntry(const QtVariant& Hash)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ENTRY] = Hash;
	return m_Driver.Call(API_SET_HASH, Request);
}

RESULT(QtVariant) CPrivacyCore::GetHashEntry(const QByteArray& HashValue)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_HASH] = QtVariant(HashValue);
	RET_GET_XVARIANT(m_Driver.Call(API_GET_HASH, Request), API_V_ENTRY);
}

STATUS CPrivacyCore::DelHashEntry(const QByteArray& HashValue)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_HASH] = QtVariant(HashValue);
	return m_Driver.Call(API_DEL_HASH, Request);
}

// Program Manager
RESULT(QtVariant) CPrivacyCore::GetPrograms()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_PROGRAMS, Request), API_V_PROGRAMS);
}

RESULT(QtVariant) CPrivacyCore::GetProgram(const class CProgramID& ID)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ID] = ID.ToVariant(SVarWriteOpt());
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_PROGRAM, Request));
}

RESULT(QtVariant) CPrivacyCore::GetProgram(uint64 UID)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_PROG_UID] = UID;
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_PROGRAM, Request));
}

RESULT(QtVariant) CPrivacyCore::GetLibraries(uint64 CacheToken)
{
	QtVariant Request(m_pMemPool);
	if(CacheToken != -1)
		Request[API_V_CACHE_TOKEN] = CacheToken;
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_LIBRARIES, Request));
}

RESULT(quint64) CPrivacyCore::SetProgram(const CProgramItemPtr& pItem)
{
	SVarWriteOpt Opts;

	auto Ret = m_Service.Call(SVC_API_SET_PROGRAM, pItem->ToVariant(Opts));
	if (Ret.IsError())
		return Ret;
	const QtVariant& Response = (const FW::CVariant&)(Ret.GetValue());
	RETURN(Response.Get(API_V_PROG_UID).To<uint64>());
}

STATUS CPrivacyCore::AddProgramTo(uint64 UID, uint64 ParentUID)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_PROG_UID] = UID;
	Request[API_V_PROG_PARENT] = ParentUID;
	return m_Service.Call(SVC_API_ADD_PROGRAM, Request);
}

STATUS CPrivacyCore::RemoveProgramFrom(uint64 UID, uint64 ParentUID, bool bDelRules, bool bKeepOne)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_PROG_UID] = UID;
	Request[API_V_PROG_PARENT] = ParentUID;
	Request[API_V_DEL_WITH_RULES] = bDelRules;
	Request[API_V_KEEP_ONE] = bKeepOne;
	return m_Service.Call(SVC_API_REMOVE_PROGRAM, Request);
}

STATUS CPrivacyCore::RefreshPrograms()
{
	QtVariant Request(m_pMemPool);
	return m_Service.Call(SVC_API_REFRESH_PROGRAMS, Request);
}

STATUS CPrivacyCore::CleanUpPrograms(bool bPurgeRules)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_PURGE_RULES] = bPurgeRules;
	return m_Service.Call(SVC_API_CLEANUP_PROGRAMS, Request);
}

STATUS CPrivacyCore::ReGroupPrograms()
{
	QtVariant Request(m_pMemPool);
	return m_Service.Call(SVC_API_REGROUP_PROGRAMS, Request);
}

STATUS CPrivacyCore::SetAllProgramRules(const QtVariant& Rules)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_RULES] = Rules;
	return m_Driver.Call(API_SET_PROGRAM_RULES, Request);
}

RESULT(QtVariant) CPrivacyCore::GetAllProgramRules()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Driver.Call(API_GET_PROGRAM_RULES, Request), API_V_RULES);
}

RESULT(QFlexGuid) CPrivacyCore::SetProgramRule(const QtVariant& Rule)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_RULE] = Rule;
	auto Ret = m_Driver.Call(API_SET_PROGRAM_RULE, Request);
	if (Ret.IsError())
		return Ret;
	return QFlexGuid(Ret.GetValue());
}

RESULT(QtVariant) CPrivacyCore::GetProgramRule(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	RET_GET_XVARIANT(m_Driver.Call(API_GET_PROGRAM_RULE, Request), API_V_RULE);
}

STATUS CPrivacyCore::DelProgramRule(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	return m_Driver.Call(API_DEL_PROGRAM_RULE, Request);
}

// Access Manager
STATUS CPrivacyCore::SetAllAccessRules(const QtVariant& Rules)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_RULES] = Rules;
	return m_Driver.Call(API_SET_ACCESS_RULES, Request);
}

RESULT(QtVariant) CPrivacyCore::GetAllAccessRules()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Driver.Call(API_GET_ACCESS_RULES, Request), API_V_RULES);
}

RESULT(QFlexGuid) CPrivacyCore::SetAccessRule(const QtVariant& Rule)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_RULE] = Rule;
	auto Ret = m_Driver.Call(API_SET_ACCESS_RULE, Request);
	if (Ret.IsError())
		return Ret;
	return QFlexGuid(Ret.GetValue());
}

RESULT(QtVariant) CPrivacyCore::GetAccessRule(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	RET_GET_XVARIANT(m_Driver.Call(API_GET_ACCESS_RULE, Request), API_V_RULE);
}

STATUS CPrivacyCore::DelAccessRule(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	return m_Driver.Call(API_DEL_ACCESS_RULE, Request);
}

STATUS CPrivacyCore::SetAccessEventAction(uint64 EventId, EAccessRuleType Action)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_EVENT_REF] = EventId;
	Request[API_V_EVENT_ACTION] = (uint32)Action;
	return m_Service.Call(SVC_API_SET_ACCESS_EVENT_ACTION, Request);
}

// Network Manager
RESULT(QtVariant) CPrivacyCore::GetFwRulesFor(const QList<const class CProgramItem*>& Nodes)
{
	QtVariant Request(m_pMemPool);
	if(!Nodes.isEmpty())
		Request[API_V_IDS] = MakeIDs(Nodes);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_FW_RULES, Request), API_V_RULES);
}

RESULT(QtVariant) CPrivacyCore::GetAllFwRules(bool bReLoad)
{
	QtVariant Request(m_pMemPool);
	if(bReLoad)
		Request[API_V_RELOAD] = true;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_FW_RULES, Request), API_V_RULES);
}

RESULT(QFlexGuid) CPrivacyCore::SetFwRule(const QtVariant& FwRule)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_RULE] = FwRule;
	auto Ret = m_Service.Call(SVC_API_SET_FW_RULE, Request);
	if (Ret.IsError())
		return Ret;
	return QFlexGuid(Ret.GetValue());
}

RESULT(QtVariant) CPrivacyCore::GetFwRule(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_FW_RULE, Request), API_V_RULE);
}

STATUS CPrivacyCore::DelFwRule(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	return m_Service.Call(SVC_API_DEL_FW_RULE, Request);
}

RESULT(FwFilteringModes) CPrivacyCore::GetFwProfile()
{
	QtVariant Request(m_pMemPool);
	auto Ret = m_Service.Call(SVC_API_GET_FW_PROFILE, Request);
	if (Ret.IsError())
		return Ret;
	const QtVariant& Response = (const FW::CVariant&)Ret.GetValue();
	return (FwFilteringModes) Response.Get(API_V_FW_RULE_FILTER_MODE).To<uint32>();
}

STATUS CPrivacyCore::SetFwProfile(FwFilteringModes Profile)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_FW_RULE_FILTER_MODE] = (uint32)Profile;
	return m_Service.Call(SVC_API_SET_FW_PROFILE, Request);
}

RESULT(FwAuditPolicy) CPrivacyCore::GetAuditPolicy()
{
	QtVariant Request(m_pMemPool);
	auto Ret = m_Service.Call(SVC_API_GET_FW_AUDIT_MODE, Request);
	if (Ret.IsError())
		return Ret;
	const QtVariant& Response = (const FW::CVariant&)Ret.GetValue();
	return (FwAuditPolicy) Response.Get(API_V_FW_AUDIT_MODE).To<uint32>();
}

STATUS CPrivacyCore::SetAuditPolicy(FwAuditPolicy Profile)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_FW_AUDIT_MODE] = (uint32)Profile;
	return m_Service.Call(SVC_API_SET_FW_AUDIT_MODE, Request);
}

RESULT(QtVariant) CPrivacyCore::GetSocketsFor(const QList<const class CProgramItem*>& Nodes)
{
	QtVariant Request(m_pMemPool);
	if(!Nodes.isEmpty())
		Request[API_V_IDS] = MakeIDs(Nodes);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_SOCKETS, Request), API_V_SOCKETS);
}

RESULT(QtVariant) CPrivacyCore::GetAllSockets()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_SOCKETS, Request), API_V_SOCKETS);
}

RESULT(QtVariant) CPrivacyCore::GetTrafficLog(const class CProgramID& ID, quint64 MinLastActivity)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ID] = ID.ToVariant(SVarWriteOpt());
	if(MinLastActivity) 
		Request[API_V_SOCK_LAST_NET_ACT] = MinLastActivity;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_TRAFFIC, Request), API_V_TRAFFIC_LOG);
}

RESULT(QtVariant) CPrivacyCore::GetAllDnsRules()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_DNS_RULES, Request), API_V_RULES);
}

STATUS CPrivacyCore::SetDnsRule(const QtVariant& FwRule)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_RULE] = FwRule;
	return m_Service.Call(SVC_API_SET_DNS_RULE, Request);
}

RESULT(QtVariant) CPrivacyCore::GetDnsRule(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_DNS_RULE, Request), API_V_RULE);
}

STATUS CPrivacyCore::DelDnsRule(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	return m_Service.Call(SVC_API_DEL_DNS_RULE, Request);
}

RESULT(QtVariant) CPrivacyCore::GetDnsCache()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_DNC_CACHE, Request), API_V_DNS_CACHE);
}

STATUS CPrivacyCore::FlushDnsCache()
{
	QtVariant Request(m_pMemPool);
	return m_Service.Call(SVC_API_FLUSH_DNS_CACHE, Request);
}

RESULT(QtVariant) CPrivacyCore::GetBlockListInfo()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_DNS_LIST_INFO, Request), API_V_DNS_LIST_INFO);
}

// Access Manager

RESULT(QtVariant) CPrivacyCore::GetHandlesFor(const QList<const class CProgramItem*>& Nodes)
{
	QtVariant Request(m_pMemPool);
	if(!Nodes.isEmpty())
		Request[API_V_IDS] = MakeIDs(Nodes);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_HANDLES, Request), API_V_HANDLES);
}

RESULT(QtVariant) CPrivacyCore::GetAllHandles()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_HANDLES, Request), API_V_HANDLES);
}

STATUS CPrivacyCore::ClearTraceLog(ETraceLogs Log, const CProgramItemPtr& pItem)
{
	if(pItem)
		OnClearTraceLog(pItem, Log);
	else {
		foreach(auto pItem, m_pProgramManager->GetItems())
			OnClearTraceLog(pItem, Log);
	}

	QtVariant Request(m_pMemPool);
	if(pItem) Request[API_V_ID] = pItem->GetID().ToVariant(SVarWriteOpt());
	Request[API_V_LOG_TYPE] = (int)Log;
	return m_Service.Call(SVC_API_CLEAR_LOGS, Request);
}

STATUS CPrivacyCore::ClearRecords(ETraceLogs Log, const CProgramItemPtr& pItem)
{
	if(pItem)
		OnClearRecords(pItem, Log);
	else {
		foreach(auto pItem, m_pProgramManager->GetItems())
			OnClearRecords(pItem, Log);
	}

	QtVariant Request(m_pMemPool);
	if(pItem) Request[API_V_ID] = pItem->GetID().ToVariant(SVarWriteOpt());
	Request[API_V_LOG_TYPE] = (int)Log;
	return m_Service.Call(SVC_API_CLEAR_RECORDS, Request);
}

STATUS CPrivacyCore::CleanUpAccessTree()
{
	QtVariant Request(m_pMemPool);
	return m_Service.Call(SVC_API_CLEANUP_ACCESS_TREE, Request);
}

// Program Item
RESULT(QtVariant) CPrivacyCore::GetLibraryStats(const class CProgramID& ID)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ID] = ID.ToVariant(SVarWriteOpt());
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_LIBRARY_STATS, Request), API_V_LIBRARIES);
}

STATUS CPrivacyCore::CleanUpLibraries(const CProgramItemPtr& pItem)
{
	if (pItem) {
		if (auto pProgram = pItem.objectCast<CProgramFile>())
			pProgram->SetLibrariesChanged();
	}
	else {
		foreach(auto pItem, m_pProgramManager->GetItems()) {
			if (auto pProgram = pItem.objectCast<CProgramFile>())
				pProgram->SetLibrariesChanged();
		}
	}

	QtVariant Request(m_pMemPool);
	if(pItem) Request[API_V_ID] = pItem->GetID().ToVariant(SVarWriteOpt());
	return m_Service.Call(SVC_API_CLEANUP_LIBS, Request);
}

RESULT(QtVariant) CPrivacyCore::GetExecStats(const class CProgramID& ID)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ID] = ID.ToVariant(SVarWriteOpt());
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_EXEC_STATS, Request));
}

RESULT(QtVariant) CPrivacyCore::GetIngressStats(const class CProgramID& ID)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ID] = ID.ToVariant(SVarWriteOpt());
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_INGRESS_STATS, Request));
}

RESULT(QtVariant) CPrivacyCore::GetAccessStats(const class CProgramID& ID, quint64 MinLastActivity)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ID] = ID.ToVariant(SVarWriteOpt());
	if(MinLastActivity) 
		Request[API_V_LAST_ACTIVITY] = MinLastActivity;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_ACCESS_STATS, Request), API_V_PROG_RESOURCE_ACCESS);
}

RESULT(QtVariant) CPrivacyCore::GetTraceLog(const class CProgramID& ID, ETraceLogs Log)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ID] = ID.ToVariant(SVarWriteOpt());
	Request[API_V_LOG_TYPE] = (uint32)Log;
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_TRACE_LOG, Request));	
}

// Volume Manager
RESULT(QtVariant) CPrivacyCore::GetVolumes()
{
	QtVariant Request(m_pMemPool);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_VOL_GET_ALL_VOLUMES, Request), API_V_VOLUMES);
}

RESULT(QtVariant) CPrivacyCore::GetVolume(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	RET_AS_XVARIANT(m_Service.Call(SVC_API_VOL_GET_VOLUME, Request));
}

STATUS CPrivacyCore::SetVolume(const QtVariant& Volume)
{
	return m_Service.Call(SVC_API_VOL_SET_VOLUME, Volume);
}

STATUS CPrivacyCore::MountVolume(const QString& Path, const QString& MountPoint, const QString& Password, bool bProtect, bool bLockdown)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_VOL_PATH] = QString(Path).replace("/","\\");
	Request[API_V_VOL_MOUNT_POINT] = MountPoint;
	Request[API_V_VOL_PASSWORD] = Password;
	Request[API_V_VOL_PROTECT] = bProtect;
	Request[API_V_VOL_LOCKDOWN] = bLockdown;
	return m_Service.Call(SVC_API_VOL_MOUNT_IMAGE, Request);
}

STATUS CPrivacyCore::DismountVolume(const QString& MountPoint)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_VOL_MOUNT_POINT] = MountPoint;
	return m_Service.Call(SVC_API_VOL_DISMOUNT_VOLUME, Request);
}

STATUS CPrivacyCore::DismountAllVolumes()
{
	QtVariant Request(m_pMemPool);
	return m_Service.Call(SVC_API_VOL_DISMOUNT_ALL, Request);
}

STATUS CPrivacyCore::CreateVolume(const QString& Path, const QString& Password, quint64 ImageSize, const QString& Cipher)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_VOL_PATH] = QString(Path).replace("/","\\");
	Request[API_V_VOL_PASSWORD] = Password;
	if(ImageSize) Request[API_V_VOL_SIZE] = ImageSize;
	if(!Cipher.isEmpty()) Request[API_V_VOL_CIPHER] = Cipher;
	return m_Service.Call(SVC_API_VOL_CREATE_IMAGE, Request);
}

STATUS CPrivacyCore::ChangeVolumePassword(const QString& Path, const QString& OldPassword, const QString& NewPassword)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_VOL_PATH] = QString(Path).replace("/","\\");
	Request[API_V_VOL_OLD_PASS] = OldPassword;
	Request[API_V_VOL_NEW_PASS] = NewPassword;
	return m_Service.Call(SVC_API_VOL_CHANGE_PASSWORD, Request);
}

// Tweak Manager
RESULT(QtVariant) CPrivacyCore::GetTweaks(uint32* pRevision)
{
	QtVariant Request(m_pMemPool);

	auto Ret = m_Service.Call(SVC_API_GET_TWEAKS, Request);
	if (Ret.IsError())
		return ERR(Ret.GetStatus());

	const QtVariant& Res = (const FW::CVariant&)Ret.GetValue();

	if (pRevision)
		*pRevision = Res.Get(API_V_REVISION).To<uint32>();

	RETURN((QtVariant&)Res.Get(API_V_TWEAKS));
}

STATUS CPrivacyCore::ApplyTweak(const QString& Id)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ID] = Id;
	return m_Service.Call(SVC_API_APPLY_TWEAK, Request);
}

STATUS CPrivacyCore::UndoTweak(const QString& Id)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ID] = Id;
	return m_Service.Call(SVC_API_UNDO_TWEAK, Request);
}

STATUS CPrivacyCore::ApproveTweak(const QString& Id)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_ID] = Id;
	return m_Service.Call(SVC_API_APPROVE_TWEAK, Request);
}

// Preset Manager

RESULT(QtVariant) CPrivacyCore::GetAllPresets()
{
	QtVariant Request(m_pMemPool);

	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_PRESETS, Request), API_V_PRESETS);
}

STATUS CPrivacyCore::SetAllPresets(const QtVariant& Presets)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_PRESETS] = Presets;
	return m_Service.Call(SVC_API_SET_PRESETS, Request);
}

RESULT(QFlexGuid) CPrivacyCore::SetPreset(const QtVariant& Preset)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_PRESET] = Preset;
	auto Ret = m_Service.Call(SVC_API_SET_PRESET, Request);
	if (Ret.IsError())
		return Ret;
	return QFlexGuid(Ret.GetValue());
}

RESULT(QtVariant) CPrivacyCore::GetPreset(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_PRESET, Request), API_V_PRESET);
}

STATUS CPrivacyCore::DelPreset(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	return m_Service.Call(SVC_API_DEL_PRESET, Request);
}

STATUS CPrivacyCore::ActivatePreset(const QFlexGuid& Guid, bool bForce)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	if (bForce)
		Request[API_V_FORCE] = true;
	return m_Service.Call(SVC_API_ACTIVATE_PRESET, Request);
}

STATUS CPrivacyCore::DeactivatePreset(const QFlexGuid& Guid)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	return m_Service.Call(SVC_API_DEACTIVATE_PRESET, Request);
}

// Other

void CPrivacyCore::ClearPrivacyLog()
{
	QtVariant Request(m_pMemPool);
	if(m_Service.Call(SVC_API_CLEAR_EVENT_LOG, Request))
		m_pEventLog->ClearLog();
}

RESULT(QtVariant) CPrivacyCore::GetServiceStats()
{
	QtVariant Request(m_pMemPool);
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_SVC_STATS, Request));
}

RESULT(QtVariant) CPrivacyCore::GetScriptLog(const QFlexGuid& Guid, EItemType Type, quint32 LastID)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	Request[API_V_TYPE] = (uint32)Type;
	if(LastID) 
		Request[API_V_LAST_ACTIVITY] = LastID;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_SCRIPT_LOG, Request), API_V_EVENT_LOG);
}

STATUS CPrivacyCore::ClearScriptLog(const QFlexGuid& Guid, EItemType Type)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	Request[API_V_TYPE] = (uint32)Type;
	return m_Service.Call(SVC_API_CLEAR_SCRIPT_LOG, Request);
}

RESULT(QtVariant) CPrivacyCore::CallScriptFunc(const QFlexGuid& Guid, EItemType Type, const QString& Name, const QtVariant& Params)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_GUID] = Guid.ToVariant(true);
	Request[API_V_TYPE] = (uint32)Type;
	Request[API_V_NAME] = Name;
	if(!Params.IsValid())
		Request[API_V_PARAMS] = Params;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_CALL_SCRIPT_FUNC, Request), API_V_DATA);
}

//
STATUS CPrivacyCore::SetWatchedPrograms(const QSet<CProgramItemPtr>& Programs)
{
	QtVariantWriter ProgramList;
	ProgramList.BeginList();
	foreach(auto pProgram, Programs)
		ProgramList.Write(pProgram->GetUID());

	QtVariant Request(m_pMemPool);
	Request[API_V_PROG_UIDS] = ProgramList.Finish();
	return m_Service.Call(SVC_API_SET_WATCHED_PROG, Request);
}

// Support
RESULT(QtVariant) CPrivacyCore::GetSupportInfo(bool bRefresh)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_REFRESH] = bRefresh;
	RET_AS_XVARIANT(m_Driver.Call(API_GET_SUPPORT_INFO, Request));
}

STATUS CPrivacyCore::SetSecureParam(const QString& Name, const void* data, size_t size)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_NAME] = Name;
	Request[API_V_DATA] = QtVariant((BYTE*)data, size);
	return m_Driver.Call(API_SET_SECURE_PARAM, Request);
}

STATUS CPrivacyCore::GetSecureParam(const QString& Name, void* data, size_t size, quint32* size_out, bool bVerify)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_NAME] = Name;
	Request[API_V_VERIFY] = bVerify;
	auto Ret = m_Driver.Call(API_GET_SECURE_PARAM, Request);
	if (Ret.IsError())
		return Ret.GetStatus();
	const FW::CVariant& Response = Ret.GetValue();
	auto Data = Response.Get(API_V_DATA);
	size_t ToCopy = Min(size, Data.GetSize());

	if (size_out) *size_out = ToCopy;
	memcpy(data, Response.Get(API_V_DATA).GetData(), ToCopy);
	return OK;
}

bool CPrivacyCore::TestSignature(const QByteArray& Data, const QByteArray& Signature)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_DATA] = QtVariant(Data);
	Request[API_V_SIGNATURE] = QtVariant(Signature);
	auto Ret = m_Driver.Call(API_VERIFY_SIGNATURE, Request);
	return !Ret.IsError();
}

STATUS CPrivacyCore::SetDatFile(const QString& FileName, const QByteArray& Data)
{
	QtVariant Request(m_pMemPool);
	Request[API_V_NAME] = FileName;
	Request[API_V_DATA] = QtVariant(Data);
	return m_Service.Call(SVC_API_SET_DAT_FILE, Request);
}

//RESULT(QByteArray) CPrivacyCore::GetDatFile(const QString& FileName)
//{
//}


////////////////////////////////////////////////////////////////////////////////
// Worker
//

CPrivacyWorker::CPrivacyWorker(QObject* parent)
	: QObject(parent)
{
}

CPrivacyWorker::~CPrivacyWorker()
{
}

void CPrivacyWorker::DoUpdate()
{
	STATUS Status;

	//uint64 uStart = GetTickCount64();

	Status = theCore->ProcessList()->Update();

	//DbgPrint("m_pProcessList->Update() took %llu ms\n", GetTickCount64() - uStart);
	//uStart = GetTickCount64();

	Status = theCore->EnclaveManager()->Update();

	//DbgPrint("m_pEnclaveManager->Update() took %llu ms\n", GetTickCount64() - uStart);
	//uStart = GetTickCount64();

	Status = theCore->HashDB()->Update();

	//DbgPrint("m_pHashDB->Update() took %llu ms\n", GetTickCount64() - uStart);
	//uStart = GetTickCount64();

	Status = theCore->ProgramManager()->Update();

	//DbgPrint("m_pProgramManager->Update() took %llu ms\n", GetTickCount64() - uStart);
	//uStart = GetTickCount64();

	Status = theCore->AccessManager()->Update();

	//DbgPrint("m_pAccessManager->Update() took %llu ms\n", GetTickCount64() - uStart);

	// todo: log errors
}


////////////////////////////////////////////////////////////////////////////////
// Hooks
//

// Hook: NtMapViewOfSection

#include "../Library/Hooking/HookUtils.h"

typedef NTSTATUS (*P_NtMapViewOfSection)(
	IN  HANDLE SectionHandle,
	IN  HANDLE ProcessHandle,
	IN  OUT PVOID *BaseAddress,
	IN  ULONG_PTR ZeroBits,
	IN  SIZE_T CommitSize,
	IN  OUT PLARGE_INTEGER SectionOffset OPTIONAL,
	IN  OUT PSIZE_T ViewSize,
	IN  ULONG InheritDisposition,
	IN  ULONG AllocationType,
	IN  ULONG Protect);

P_NtMapViewOfSection NtMapViewOfSectionTramp = NULL;

bool IsMemoryReadable(PVOID Address)
{
	MEMORY_BASIC_INFORMATION mbi;
	if (VirtualQuery(Address, &mbi, sizeof(mbi)) == 0)
		return false;

	if (mbi.Protect & (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE))
		return true;

	return false;
}

NTSTATUS NTAPI MyMapViewOfSection(
	IN  HANDLE SectionHandle,
	IN  HANDLE ProcessHandle,
	IN  OUT PVOID* BaseAddress,
	IN  ULONG_PTR ZeroBits,
	IN  SIZE_T CommitSize,
	IN  OUT PLARGE_INTEGER SectionOffset OPTIONAL,
	IN  OUT PSIZE_T ViewSize,
	IN  ULONG InheritDisposition,
	IN  ULONG AllocationType,
	IN  ULONG Protect)
{
	NTSTATUS status = NtMapViewOfSectionTramp(SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Protect);
	if (NT_SUCCESS(status))
	{
		if (BaseAddress && *BaseAddress && !IsMemoryReadable(*BaseAddress))
		{
			DbgPrint("MyMapViewOfSection: Invalid BaseAddress: %p", *BaseAddress);
			status = STATUS_ACCESS_DENIED;
		}
	}
	return status;
}

// Hook: LoadLibraryExW

typedef HMODULE (*P_LoadLibraryExW)(
	LPCWSTR lpLibFileName,
	HANDLE hFile,
	DWORD dwFlags);

P_LoadLibraryExW LoadLibraryExWTramp = NULL;

HMODULE NTAPI MyLoadLibraryExW(
	LPCWSTR lpLibFileName,
	HANDLE hFile,
	DWORD dwFlags)
{
	bool bNonExecutable = ((dwFlags & LOAD_LIBRARY_AS_IMAGE_RESOURCE) && (dwFlags & (LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE)));

	if (bNonExecutable)
		theCore->Driver()->SetIgnorePendingImageLoad(true);

	HMODULE hModule = LoadLibraryExWTramp(lpLibFileName, hFile, dwFlags);

	if (bNonExecutable)
		theCore->Driver()->SetIgnorePendingImageLoad(false);

	return hModule;
}

// Init

STATUS CPrivacyCore::InitHooks()
{
	//
	// If a dll is not signed like a shell extension for the default windows file open dialog,
	// or alike, we have a problem as our driver when ImageLoadProtection == TRUE will block the loading of the dll
	// and unmap the just loaded section from the driver, so we add a sanity check for NtMapViewOfSection
	// if it returns no error but the memory is not readable return STATUS_ACCESS_DENIED instead.
	//

	HookFunction(GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtMapViewOfSection"), MyMapViewOfSection, (VOID**)&NtMapViewOfSectionTramp);

	//
	// On windows 7 the notifier set by PsSetLoadImageNotifyRoutine is als called for non executable image load
	// we need those loads to read resoruces and icons, so we need to tell the driver upfront to skip the image verificatoin for the upcomming load
	//

	if (g_WindowsVersion < WINDOWS_10)
		HookFunction(LoadLibraryExW, MyLoadLibraryExW, (VOID**)&LoadLibraryExWTramp);

	return OK;
}